
## type of class
### static class
- کلاسی که قابل ارث بری نیست.
- معمولا برای گسترش کلاس های پیش فرض استفاده می شود مثلا کلاس استرینگ C# را گسترش دهیم.
- نیاز به وهله سازی ندارد.
### partial class
-  تعریف یک کلاس که اجزای آن در بیش از یک فایل قرار دارند است. به عبارت دیگر، یک کلاس ممکن است در چندین فایل مختلف تعریف شود و هر بخش از آن در یک فایل جداگانه قرار داشته باشد. این قابلیت برای کلاس‌های بزرگ و پیچیده مفید است که تعداد اعضا و روش‌های فعالیتشان زیاد است.
 
```
// MyClass1.cs
public partial class MyClass {
   // تعریف بخش اول کلاس
}

// MyClass2.cs
public partial class MyClass {
   // تعریف بخش دوم کلاس
}

// MyClass3.cs
public partial class MyClass {
   // تعریف بخش سوم کلاس
}
```

### abstract class
قابلیت نمونه سازی از این کلاس وجود ندارد و فقط برای ارث بری است
### sealed class

آخرین کلاس در زمان ارث بری است و دیگر از این کلاس نمیشه ارث بری کرد.

## Reflection
به معنا انعکاس برای استرخ متا از آبجکت و کلاس استفاده می شود.

## Object
به شی نمونه سازی شده از کلاس میگویند.

## Abstraction
به معنای انتزاع و چیز هایی را که کاربر نیاز داره فقط ببینه راننده میدونه گاز بده ماشین حرکت میکنه ولی نیاز نیست بدونه موتور چجوری کار میکنه.
## Overriding vs Overloading
### Overriding
متدی که در کلاس پدر استفاده شده و در فرزند میخواد بازنویسی بشود از این مفهوم استفاده می شود
### Overloading
همون مفهوم پلی مورفیسم یعنی تعریف چند متد با تعداد پارامترهای مختلف
## abstract vs interface
- اینترفیس از خاصیت multiple inhirtance پشتیبانی میکنه ولی abstract نه.
- abstract میتوان یک کلاس را تعرف و پیاده سازی کرد ولی اینترفیس فقط میشه تعریف کرد.
- abstract را برای مواقعی که حتما لازم نیست متدها پیاده سازی شوداستفاده میشود
- interface به هیچ عنوان کانستراکتور ندارد 
- هیچکدام قابلیت نمونه سازی ندارند.

## out, ref, params
- params از پشت ورودی یک تابع بیاید این ورودی تعداد نامشخص ورودی میگیرد
- out لازم نیست مقدار اولیه بگیرد ولی ref حتما باید مقدار اولیه بگیرد

## Exteionshon method
زمانی که یک متد برای کلاسی که به آن دسترسی ندارم بخواهیم تعریف کنیم مثلا متدی برای کلاس string  در خود هسته #C بخواهیم تعریف کنیم.

## Encapsulation 
اگر یک کلاسی سطح دسترسی آن مشخص نشود پیش فرض internal قرار میگرد.
### public
دسترسی کامل در کلاس فعلی و همه کلاس ها و همه پروژه که اسمبلی شده از این کلاس
### private
فقط در کلاس جاری قابل دسترسی است و لا غیر
### internal
در همه کلاس های پروژه فعلی استفاده می شود و نه در پروژه های اسمبلی
### protected
### protectedInternal

## constractor of class
:

#### کانستراکتور پیش فرض: 
این کانستراکتور برای ساخت شی‌های پیش فرض مورد استفاده قرار می‌گیرد و به صورت خودکار فراخوانی می‌شود.

#### کانستراکتور پارامتری:
در این نوع کانستراکتور، پارامترهایی به آن ارسال می‌شوند که برای مقداردهی اولیه خصوصیات شی‌ها استفاده می‌شوند.

#### کانستراکتور استاتیک: 
این نوع کانستراکتور برای ایجاد متد‌های استاتیک به کار می‌رود و هنگام بارگذاری یک کلاس، فقط یک بار فراخوانی می‌شود.

## throw vs throw x
throw اطلاعات بیشتری بر میگرداند

## ArrayList vs HashTable 
### ArrayList
در افزودن کلید نیاز ندارد
### HashTable
در افزودن کلید نیاز دارد.


## IEnumerable Vs IQueryable
### IEnumerable
یک خصوصیتی که باعث می شود لیست ها قابل پیمایش باشد
### IQueryable
برای لیست هایی که از سمت دیتابیس می آید و برای Linq کاربرد دارد. 

## Delegate 
یک متغیر است که میتوان رفرنس یک یا چند متد را توی خودش نگه داره پارامتری که بهDelegate پاس داده میشه خودش یک متد است.
### Anonymous Delegate
دلیگیتی که متد را داخلی خودش میسازه و نیاز به فراخوانی متد ثالث ندارد.
### Multicast Delegate
میتواند چندین متد را داخل آن رفرنس دهی کرد.
## this
اشاره به نمونه ای که داخل کلاس داریم

## const vs readonly
const در زمان تعریف باید مقدار دهی شود 
readonly میتوان در کانستکراتور مقدار دهی شود

## var vs dynamic 
var متغیر کامپایل تایم تعریف میکند 
dynamic متغیر ران تایم تعریف میکند

## Boxing vs unboxing
وقتی یک مقدار value type را داخل refrence type میریزیم باکسینگ رخ میدهد و زمانی که تایپ کستینگ میکنم  unboxing رخ میدهد
## sring vs string builder
برای الحاق رشته ها فضای جدید میگیرد ولی در string builder فضای جدید نمیگیرد.

## SOLID
### Open closed princiople
باید بتوان عملکرد کلاس را بدون تغییر گسترش داد.
کلاس نسبت به تغییر بسته ولی نسبت به توسعه باز باشد

### Dependency inversion
کلاس سطح بالاتر نباید به کلاس های سطح پایینتر وابسته باشند هر دو باید به انتزاعات وابسته باشد.
